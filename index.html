<!DOCTYPE html>
<html lang="it">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>FreeCharge ‚Äî colonnine gratuite entro 30 km</title>

  <!-- PWA -->
  <link rel="manifest" href="manifest.webmanifest">
  <meta name="theme-color" content="#0aa55c" />
  <link rel="icon" sizes="192x192" href="icons/icon-192.png">
  <link rel="apple-touch-icon" href="icons/icon-192.png">

  <!-- Leaflet -->
  <link rel="preconnect" href="https://unpkg.com" crossorigin>
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
  <!-- Load Leaflet JS synchronously so it is available before our inline script executes -->
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>

  <style>
    :root { --accent:#0aa55c; }
    /* Make the body a flex container so the map section can flexibly take up
       the remaining vertical space. Setting `height: 100vh` ensures the body
       fills the viewport and that flex items can base their sizes off of it. */
    html,body{ height:100vh; margin:0; display:flex; flex-direction:column; font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; }
    header{ padding:10px 12px; background:#111; color:#fff; display:flex; align-items:center; gap:10px; flex-wrap:wrap }
    header h1{ font-size:18px; margin:0; font-weight:600 }
    header small{ opacity:.8 }
    #panel{ padding:10px 12px; display:flex; gap:12px; align-items:center; flex-wrap:wrap; background:#f6f7f8; border-bottom:1px solid #e6e6e6 }
    #map{ flex:1 1 auto; min-height:300px; }
    #list{ height:200px; overflow:auto; border-top:1px solid #e8e8e8; padding:8px 12px; }
    .btn{ background:var(--accent); border:0; color:#fff; padding:8px 12px; border-radius:6px; cursor:pointer; font-weight:600 }
    .btn.secondary{ background:#444 }
    .pill{ padding:2px 8px; border-radius:999px; font-size:12px; font-weight:600; display:inline-block }
    .pill.osm{ background:#e6f7ee; color:#0a7a4a; border:1px solid #bfead3 }
    .pill.ocm{ background:#e6f0fb; color:#2a56c6; border:1px solid #c5d4fb }
    .item{ padding:8px 0; border-bottom:1px dashed #ddd }
    .muted{ color:#666 }
    .row{ display:flex; align-items:center; gap:10px; flex-wrap:wrap }
    label{ font-size:14px }
    input[type="text"]{ padding:6px 8px; border:1px solid #ccc; border-radius:6px }
    input[type="range"]{ width:140px }
    /* Added statusbar, spinner, and more button styles for incremental loading */
    #statusbar{ padding:8px 12px; display:flex; gap:8px; align-items:center; background:#fff; border-bottom:1px solid #eee }
    #spinner{ width:16px; height:16px; border:2px solid #ddd; border-top-color:var(--accent); border-radius:50%; animation:spin 0.9s linear infinite; display:none }
    @keyframes spin { to { transform:rotate(360deg) } }
    #moreBtn{ display:none; margin-left:auto }
  </style>
</head>
<body>
  <header>
    <h1>FreeCharge</h1><small>‚Äî colonnine gratuite entro 30 km</small>
  </header>

  <div id="panel" class="row">
    <button id="btnLoc" class="btn">üìç Usa la mia posizione</button>
    <button id="btnSearch" class="btn secondary">üîé Cerca nell‚Äôarea mappa</button>
    <label>Raggio: <span id="radiusOut">30</span> km
      <input id="radius" type="range" min="5" max="50" step="1" value="30">
    </label>
    <label><input id="incOCM" type="checkbox"> Includi OpenChargeMap</label>
    <label>OCM API key: <input id="ocmKey" type="text" size="24" placeholder="(opzionale)"></label>
  </div>

  <div id="statusbar">
    <div id="spinner"></div>
    <div id="statusText" class="muted">Pronto.</div>
    <button id="moreBtn" class="btn secondary">Carica altre (espandi raggio)</button>
  </div>

  <div id="map"></div>
  <div id="list"></div>

  <script>
  'use strict';

  /* ===================== PWA SW ===================== */
  if ('serviceWorker' in navigator) {
    addEventListener('load', () => {
      navigator.serviceWorker.register('./service-worker.js')
        .then(() => console.log('SW registrato'))
        .catch(err => console.warn('SW non registrato', err));
    });
  }

  /* ===================== MAPPA ===================== */
  const map = L.map('map').setView([44.418, 11.913], 12); // Lugo (RA) default
  L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png',{
    maxZoom: 19,
    attribution:'¬© OpenStreetMap'
  }).addTo(map);
  const markers = L.layerGroup().addTo(map);

  /* ===================== UI refs ===================== */
  const els = {
    btnLoc: document.getElementById('btnLoc'),
    btnSearch: document.getElementById('btnSearch'),
    radius: document.getElementById('radius'),
    radiusOut: document.getElementById('radiusOut'),
    incOCM: document.getElementById('incOCM'),
    ocmKey: document.getElementById('ocmKey'),
    list: document.getElementById('list'),
    spinner: document.getElementById('spinner'),
    statusText: document.getElementById('statusText'),
    moreBtn: document.getElementById('moreBtn')
  };
  els.radius.addEventListener('input', () => els.radiusOut.textContent = els.radius.value);

  /* Prefill OCM key + toggle */
  els.ocmKey.value = '9a781dbf-a3ac-4a5f-aaf6-808505823a74';
  els.incOCM.checked = true;

  /* ===================== UTIL ===================== */
  function haversine(lat1, lon1, lat2, lon2){
    const R = 6371000, toRad = d => d*Math.PI/180;
    const dLat = toRad(lat2-lat1), dLon = toRad(lon2-lon1);
    const a = Math.sin(dLat/2)**2 + Math.cos(toRad(lat1))*Math.cos(toRad(lat2))*Math.sin(dLon/2)**2;
    return 2*R*Math.asin(Math.sqrt(a));
  }
  function gridKey(lat, lon){
    return (Math.round(lat*100)/100).toFixed(2)+'_'+(Math.round(lon*100)/100).toFixed(2);
  }
  function setStatus(text, busy=false){
    els.statusText.textContent = text;
    els.spinner.style.display = busy ? 'inline-block' : 'none';
  }
  function batchAddMarkers(points){
    let i=0;
    function step(){
      const end = Math.min(i+40, points.length);
      for(; i<end; i++){
        const p = points[i];
        const popupOperator = p.operator || '';
        const popupConnectors = (p.connectors && p.connectors.length) ? p.connectors.join(', ') : '‚Äî';
        L.marker([p.lat,p.lon]).addTo(markers)
          .bindPopup('<b>'+p.name+'</b><br>' + popupOperator + '<br><small>' + popupConnectors + '</small>');
      }
      if(i < points.length) requestAnimationFrame(step);
    }
    requestAnimationFrame(step);
  }
  function dedupeByProximity(items, meters=25){
    const out = [];
    for(const p of items){
      const match = out.find(o => haversine(o.lat,o.lon,p.lat,p.lon) <= meters);
      if(!match) out.push(p);
    }
    return out;
  }

  /* ===================== NORMALIZZAZIONE OSM ===================== */
  function connectorsFromOSMTags(tags){
    tags = tags || {};
    const mapKey = {
      'socket:type2':'Type2',
      'socket:type2_combo':'CCS2',
      'socket:chademo':'CHAdeMO',
      'socket:type1':'Type1',
      'socket:schuko':'Schuko',
      'socket:tesla_supercharger':'Tesla SC'
    };
    const res = [];
    for(const k in mapKey){
      if(Object.prototype.hasOwnProperty.call(tags, k)){
        const v = (tags[k] || '').toString().trim().toLowerCase();
        if(v && v !== 'no' && v !== '0') res.push(mapKey[k]);
      }
    }
    return res;
  }
  function normalizeOSM(el){
    const isNode = Object.prototype.hasOwnProperty.call(el, 'lat');
    const lat = isNode ? el.lat : ((el.center && el.center.lat) || null);
    const lon = isNode ? el.lon : ((el.center && el.center.lon) || null);
    const tags = el.tags || {};
    if(lat==null || lon==null) return null;
    const name = tags.name || 'Stazione di ricarica';
    const operator = tags.operator || tags.brand || null;
    const connectors = connectorsFromOSMTags(tags);
    const power = tags['charging_power'] || tags['power'] || null;
    const free = (tags.fee && tags.fee.toString().toLowerCase()==='no') ||
                 (tags.charge && tags.charge.toString().trim()==='0');
    return { source:'OSM', free: !!free, name, operator, lat, lon, raw:tags, power, connectors };
  }

  /* ===================== NORMALIZZAZIONE OCM ===================== */
  function isOCMFree(usageCost){
    if(!usageCost) return true;
    const s = usageCost.toString().toLowerCase();
    return /\bfree\b|\bgratis?\b|(^|\s)0\s*‚Ç¨|‚Ç¨\s*0\b|free\s*charging/.test(s);
  }
  function normalizeOCM(item){
    const a = item.AddressInfo || {};
    if(a.Latitude==null || a.Longitude==null) return null;
    const connections = Array.isArray(item.Connections) ? item.Connections : [];
    const connectorTitles = connections
      .map(c => (c.ConnectionType && c.ConnectionType.Title) || null)
      .filter(Boolean)
      .map(t => {
        const s = t.toLowerCase();
        if(s.includes('type 2')) return 'Type2';
        if(s.includes('ccs') || s.includes('combo')) return 'CCS';
        if(s.includes('chademo')) return 'CHAdeMO';
        if(s.includes('schuko')) return 'Schuko';
        if(s.includes('tesla')) return 'Tesla';
        return t;
      });
    let power = null;
    if(connections.length){
      const k = connections.map(c => c.PowerKW || c.Power).filter(Boolean);
      if(k.length) power = Math.max(...k) + ' kW';
    }
    return {
      source:'OCM',
      free: isOCMFree(item.UsageCost),
      name: a.Title || 'Punto di ricarica',
      operator: (item.OperatorInfo && item.OperatorInfo.Title) || null,
      lat: a.Latitude,
      lon: a.Longitude,
      power, connectors: [...new Set(connectorTitles)],
      raw: item
    };
  }

  /* ===================== DATI: OSM + OCM ===================== */
  async function fetchOSM(lat, lon, radiusKm){
    const R = Math.round(radiusKm * 1000);
    const q = `
      [out:json][timeout:25];
      (
        node["amenity"="charging_station"]["fee"="no"](around:${R},${lat},${lon});
        node["amenity"="charging_station"]["charge"="0"](around:${R},${lat},${lon});
        way["amenity"="charging_station"]["fee"="no"](around:${R},${lat},${lon});
        way["amenity"="charging_station"]["charge"="0"](around:${R},${lat},${lon});
        relation["amenity"="charging_station"]["fee"="no"](around:${R},${lat},${lon});
        relation["amenity"="charging_station"]["charge"="0"](around:${R},${lat},${lon});
      );
      out center tags;
    `.trim();
    const res = await fetch('https://overpass-api.de/api/interpreter', {
      method:'POST',
      headers:{ 'Content-Type':'application/x-www-form-urlencoded;charset=UTF-8' },
      body: 'data=' + encodeURIComponent(q)
    });
    if(!res.ok) throw new Error('Overpass API error: ' + res.status);
    const json = await res.json();
    const arr = (json.elements || [])
      .map(normalizeOSM)
      .filter(Boolean)
      .map(o => ({...o, free:true}));
    return arr;
  }
  async function fetchOCM(lat, lon, radiusKm, apiKey){
    const url = new URL('https://api.openchargemap.io/v3/poi');
    const params = {
      output: 'json',
      latitude: lat, longitude: lon,
      distance: radiusKm, distanceunit: 'KM',
      countrycode: 'IT',
      maxresults: 200, compact: true, verbose: false
    };
    Object.entries(params).forEach(([k,v]) => url.searchParams.set(k,v));
    if(apiKey) url.searchParams.set('key', apiKey);
    const res = await fetch(url.toString());
    if(!res.ok) throw new Error('OCM API error: ' + res.status);
    const json = await res.json();
    return json.map(normalizeOCM).filter(Boolean).filter(p => p.free);
  }

  /* ===================== CACHE (localStorage) ===================== */
  const CACHE_TTL_MS = 15*60*1000;
  function cacheGet(key){
    try{
      const raw = localStorage.getItem(key);
      if(!raw) return null;
      const obj = JSON.parse(raw);
      if(Date.now() - obj.t > CACHE_TTL_MS) return null;
      return obj.data || null;
    }catch{ return null; }
  }
  function cacheSet(key, data){
    try{ localStorage.setItem(key, JSON.stringify({t:Date.now(), data})); }catch{}
  }

  /* ===================== RENDER LISTA ===================== */
  function renderList(items){
    const frag = document.createDocumentFragment();
    items.forEach(p => {
      const div = document.createElement('div');
      div.className = 'item';
      const conns = (p.connectors && p.connectors.length) ? p.connectors.join(', ') : '‚Äî';
      div.innerHTML = '<b>'+p.name+'</b> <span class="pill '+(p.source==='OSM'?'osm':'ocm')+'">'+p.source+'</span><br>'+
        '<small class="muted">'+(p.operator || '')+'</small><br>'+
        '<small>'+conns+'</small>';
      frag.appendChild(div);
    });
    els.list.replaceChildren(frag);
  }

  /* ===================== LOGICA: caricamento incrementale ===================== */
  let currentCenter = map.getCenter();
  let staged = [5,10,20,30];
  let stagedIndex = 0;
  let combinedPoints = [];

  function getCacheKey(lat, lon, radiusKm){
    return 'fcache_'+gridKey(lat,lon)+'_'+radiusKm;
  }
  async function loadRadius(lat, lon, radiusKm){
    const key = getCacheKey(lat, lon, radiusKm);
    const fromCache = cacheGet(key);
    if(fromCache){ return fromCache; }
    const tasks = [ fetchOSM(lat, lon, radiusKm) ];
    if(els.incOCM.checked){
      tasks.push(fetchOCM(lat, lon, radiusKm, els.ocmKey.value.trim()));
    }
    const results = await Promise.allSettled(tasks);
    const merged = []
      .concat(results[0].status==='fulfilled' ? results[0].value : [])
      .concat(results[1] && results[1].status==='fulfilled' ? results[1].value : []);
    const unique = dedupeByProximity(merged, 30);
    cacheSet(key, unique);
    return unique;
  }
  async function stagedLoad(startLat, startLon, fromIndex=0){
    stagedIndex = fromIndex;
    els.moreBtn.style.display = (stagedIndex < staged.length-1) ? 'inline-block' : 'none';
    for(; stagedIndex<staged.length; stagedIndex++){
      const r = staged[stagedIndex];
      setStatus('Cerco entro '+r+' km...', true);
      const points = await loadRadius(startLat, startLon, r);
      const existing = combinedPoints;
      const newly = points.filter(p => !existing.some(e => haversine(e.lat,e.lon,p.lat,p.lon) < 20));
      if(newly.length){
        combinedPoints = dedupeByProximity(existing.concat(newly), 20);
        batchAddMarkers(newly);
        renderList(combinedPoints);
      }
      setStatus('Trovati '+combinedPoints.length+' punti (entro '+r+' km).', stagedIndex < staged.length-1);
      els.moreBtn.style.display = (stagedIndex < staged.length-1) ? 'inline-block' : 'none';
      if(stagedIndex === 0) break;
    }
  }

  /* ===================== EVENTI UI ===================== */
  els.btnLoc.addEventListener('click', () => {
    setStatus('Rilevo la posizione...', true);
    navigator.geolocation.getCurrentPosition(async pos => {
      const lat = pos.coords.latitude, lon = pos.coords.longitude;
      currentCenter = L.latLng(lat, lon);
      map.setView(currentCenter, 13);
      markers.clearLayers();
      els.list.textContent = '';
      combinedPoints = [];
      stagedIndex = 0;
      els.radius.value = 10; els.radiusOut.textContent = '10';
      staged = [5,10,20,30];
      await stagedLoad(lat, lon, 0);
    }, err => {
      setStatus('Posizione non disponibile. Usa ‚ÄúCerca nell‚Äôarea mappa‚Äù.', false);
    }, { enableHighAccuracy:true, timeout:10000, maximumAge:60000 });
  });
  els.btnSearch.addEventListener('click', async () => {
    const c = map.getCenter();
    currentCenter = c;
    markers.clearLayers(); els.list.textContent='';
    combinedPoints = [];
    const maxR = parseInt(els.radius.value,10) || 30;
    staged = [5, Math.min(10,maxR)];
    if(maxR>10) staged.push(20);
    if(maxR>20) staged.push(30);
    setStatus('Cerco nell‚Äôarea visualizzata...', true);
    await stagedLoad(c.lat, c.lng, 0);
  });
  els.moreBtn.addEventListener('click', async () => {
    if(!currentCenter) return;
    const c = currentCenter;
    if(stagedIndex < staged.length-1){
      stagedIndex++;
      const r = staged[stagedIndex];
      setStatus('Espando a '+r+' km...', true);
      const points = await loadRadius(c.lat, c.lng, r);
      const newly = points.filter(p => !combinedPoints.some(e => haversine(e.lat,e.lon,p.lat,p.lon) < 20));
      if(newly.length){
        combinedPoints = dedupeByProximity(combinedPoints.concat(newly), 20);
        batchAddMarkers(newly);
        renderList(combinedPoints);
      }
      setStatus('Trovati '+combinedPoints.length+' punti (entro '+r+' km).', stagedIndex < staged.length-1);
      els.moreBtn.style.display = (stagedIndex < staged.length-1) ? 'inline-block' : 'none';
    } else {
      els.moreBtn.style.display = 'none';
    }
  });

  /* ===================== AVVIO RAPIDO ===================== */
  addEventListener('load', async () => {
    els.radius.value = 10; els.radiusOut.textContent = '10';
    const c = map.getCenter();
    currentCenter = c;
    markers.clearLayers(); els.list.textContent='';
    combinedPoints = [];
    staged = [5,10,20,30];
    setStatus('Carico punti vicini (5 km)...', true);
    await stagedLoad(c.lat, c.lng, 0);
  });
  </script>
</body>
</html>