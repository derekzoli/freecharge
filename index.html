<!DOCTYPE html>
<html lang="it">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>FreeCharge ‚Äî colonnine gratuite entro 30 km</title>

  <!-- PWA -->
  <link rel="manifest" href="manifest.webmanifest">
  <meta name="theme-color" content="#0aa55c" />
  <link rel="icon" sizes="192x192" href="icons/icon-192.png">
  <link rel="apple-touch-icon" href="icons/icon-192.png">

  <!-- Leaflet -->
  <link rel="preconnect" href="https://unpkg.com" crossorigin>
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
  <!-- Load Leaflet JS synchronously so it is available before our inline script executes -->
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>

  <style>
    :root { --accent:#0aa55c; }
    /* Make the body a flex container so the map section can flexibly take up
       the remaining vertical space. Setting `height: 100vh` ensures the body
       fills the viewport and that flex items can base their sizes off of it. */
    html,body{ height:100vh; margin:0; display:flex; flex-direction:column; font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; }
    header{ padding:10px 12px; background:#111; color:#fff; display:flex; align-items:center; gap:10px; flex-wrap:wrap }
    /* Version info appears at the far right of the header bar.  It uses margin-left:auto to push it to
       the end of the flex container and a small, semi-transparent font for subtlety. */
/*
   Version note (date/time) styles. It floats to the far right of the header via
   margin-left:auto and uses a lighter colour on the dark header for better
   contrast. We avoid separate opacity so that readers with low vision can
   still read the text. The colour uses an RGBA value to let the background
   bleed through slightly. Feel free to tweak the alpha channel (0.6) for
   subtler or stronger contrast.
*/
#versionInfo{
  margin-left:auto;
  font-size:12px;
  color:rgba(255,255,255,0.6);
  font-weight:400;
}
    header h1{ font-size:18px; margin:0; font-weight:600 }
    header small{ opacity:.8 }
    #panel{ padding:10px 12px; display:flex; gap:12px; align-items:center; flex-wrap:wrap; background:#f6f7f8; border-bottom:1px solid #e6e6e6 }
    #map{ flex:1 1 auto; min-height:300px; }
    #list{ height:200px; overflow:auto; border-top:1px solid #e8e8e8; padding:8px 12px; }
    .btn{ background:var(--accent); border:0; color:#fff; padding:8px 12px; border-radius:6px; cursor:pointer; font-weight:600 }
    .btn.secondary{ background:#444 }
    .pill{ padding:2px 8px; border-radius:999px; font-size:12px; font-weight:600; display:inline-block }
    .pill.osm{ background:#e6f7ee; color:#0a7a4a; border:1px solid #bfead3 }
    .pill.ocm{ background:#e6f0fb; color:#2a56c6; border:1px solid #c5d4fb }
    .item{ padding:8px 0; border-bottom:1px dashed #ddd }
    .muted{ color:#666 }
    .row{ display:flex; align-items:center; gap:10px; flex-wrap:wrap }
    label{ font-size:14px }
    input[type="text"]{ padding:6px 8px; border:1px solid #ccc; border-radius:6px }
    input[type="range"]{ width:140px }
    /* Added statusbar, spinner, and more button styles for incremental loading */
    #statusbar{ padding:8px 12px; display:flex; gap:8px; align-items:center; background:#fff; border-bottom:1px solid #eee }
    #spinner{ width:16px; height:16px; border:2px solid #ddd; border-top-color:var(--accent); border-radius:50%; animation:spin 0.9s linear infinite; display:none }
    @keyframes spin { to { transform:rotate(360deg) } }
    #moreBtn{ display:none; margin-left:auto }

    /* Modal styles for settings dialog */
    .modal{ position:fixed; inset:0; z-index:9999 }
    .modal-backdrop{ position:absolute; inset:0; background:rgba(0,0,0,.4) }
    .modal-card{ position:relative; margin:12vh auto 0; max-width:520px; background:#fff; border-radius:10px; padding:16px; box-shadow:0 20px 50px rgba(0,0,0,.25) }
    .field{ margin:12px 0 }
    .password-wrap{ display:flex; gap:8px; align-items:center }
    .btn.small{ padding:6px 8px; font-size:13px }
  </style>
</head>
<body>
  <header>
    <h1>FreeCharge</h1><small>‚Äî colonnine gratuite (max 30 km)</small><span id="versionInfo"></span>
  </header>

  <div id="panel" class="row">
    <button id="btnLoc" class="btn">üìç Usa la mia posizione</button>
    <button id="btnSearch" class="btn secondary">üîé Cerca nell‚Äôarea mappa</button>
    <label>Raggio: <span id="radiusOut">10</span> km
      <input id="radius" type="range" min="5" max="50" step="1" value="10">
    </label>
    <label><input id="incOCM" type="checkbox"> Includi OpenChargeMap</label>
    <!-- Removed always-visible OCM key input.  A dedicated settings modal will handle the key. -->
    <label><input id="onlyFreeStrict" type="checkbox" checked> Solo gratuite (rigoroso)</label>
    <!-- Button to open the settings modal.  Placed at the far right via margin-left:auto. -->
    <button id="btnSettings" class="btn secondary" style="margin-left:auto">‚öôÔ∏è Impostazioni</button>
  </div>

  <div id="statusbar">
    <div id="spinner"></div>
    <div id="statusText" class="muted">Pronto.</div>
    <button id="moreBtn" class="btn secondary">Carica altre (espandi raggio)</button>
  </div>

  <!-- Modal impostazioni.  Hidden by default and shown when the user clicks the settings button. -->
  <div id="settingsModal" class="modal" aria-hidden="true" style="display:none">
    <div class="modal-backdrop"></div>
    <div class="modal-card" role="dialog" aria-modal="true" aria-labelledby="settingsTitle">
      <h3 id="settingsTitle">Impostazioni</h3>

      <div class="field">
        <label for="ocmKeyInput">OCM API key</label>
        <div class="password-wrap">
          <input id="ocmKeyInput" type="password" placeholder="inserisci chiave" autocomplete="off">
          <button id="toggleKey" type="button" class="btn secondary small">Mostra</button>
        </div>
        <small class="muted">La chiave √® salvata solo nel tuo dispositivo (localStorage).</small>
      </div>

      <div class="field">
        <label><input id="strictInModal" type="checkbox"> Solo gratuite (rigoroso)</label>
      </div>

      <div class="actions">
        <button id="saveSettings" class="btn">Salva</button>
        <button id="closeSettings" class="btn secondary">Chiudi</button>
      </div>
    </div>
  </div>

  <div id="map"></div>
  <div id="list"></div>

  <script>
  'use strict';

  /* ===================== PWA SW ===================== */
  if ('serviceWorker' in navigator) {
    addEventListener('load', () => {
      navigator.serviceWorker.register('./service-worker.js')
        .then(() => console.log('SW registrato'))
        .catch(err => console.warn('SW non registrato', err));
    });
  }

  /* ===================== MAPPA ===================== */
  const map = L.map('map').setView([44.418, 11.913], 12); // Lugo (RA) default
  L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png',{
    maxZoom: 19,
    attribution:'¬© OpenStreetMap'
  }).addTo(map);
  const markers = L.layerGroup().addTo(map);

  /* ===================== UI refs ===================== */
  const els = {
    btnLoc: document.getElementById('btnLoc'),
    btnSearch: document.getElementById('btnSearch'),
    radius: document.getElementById('radius'),
    radiusOut: document.getElementById('radiusOut'),
    incOCM: document.getElementById('incOCM'),
    onlyFreeStrict: document.getElementById('onlyFreeStrict'),
    list: document.getElementById('list'),
    spinner: document.getElementById('spinner'),
    statusText: document.getElementById('statusText'),
    moreBtn: document.getElementById('moreBtn'),
    btnSettings: document.getElementById('btnSettings'),
    settingsModal: document.getElementById('settingsModal'),
    ocmKeyInput: document.getElementById('ocmKeyInput'),
    toggleKey: document.getElementById('toggleKey'),
    saveSettings: document.getElementById('saveSettings'),
    closeSettings: document.getElementById('closeSettings'),
    strictInModal: document.getElementById('strictInModal')
  };
  els.radius.addEventListener('input', () => els.radiusOut.textContent = els.radius.value);

  // ===================== VERSION INFO =====================
  // Display the current date and time in the header.  We obtain a localized string
  // using the Italian locale with short date and time formats.  The element is
  // optional and will be present if defined in the HTML header.
  const versionElem = document.getElementById('versionInfo');
  if (versionElem) {
    const now = new Date();
    versionElem.textContent = now.toLocaleString('it-IT', { dateStyle: 'short', timeStyle: 'short' });
  }

  /* ===================== SETTINGS LOAD ===================== */
  // Keys for storing values in localStorage.  We persist the OCM API key and the
  // strict (rigorous) filtering flag.  Values are per-device only.
  const STORAGE_KEYS = {
    ocmKey: 'fc_ocm_key',
    strict: 'fc_only_free_strict'
  };

  // Save the current settings from the modal into localStorage.
  function saveSettingsToStorage(){
    try{
      localStorage.setItem(STORAGE_KEYS.ocmKey, els.ocmKeyInput.value.trim());
      localStorage.setItem(STORAGE_KEYS.strict, els.strictInModal.checked ? '1' : '0');
    }catch{}
  }

  // Load settings from localStorage.  Returns an object with fields:
  // { ocmKey: string, strict: boolean }.  If values are absent, defaults
  // to empty string and true (strict filtering enabled).
  function loadSettingsFromStorage(){
    try{
      const key = localStorage.getItem(STORAGE_KEYS.ocmKey) || '';
      const strict = localStorage.getItem(STORAGE_KEYS.strict);
      return { ocmKey: key, strict: strict == null ? true : strict === '1' };
    }catch{
      return { ocmKey:'', strict:true };
    }
  }

  // Initialize UI based on stored settings: update the strict checkbox and leave
  // the API key hidden (only editable via the modal).
  const initSettings = loadSettingsFromStorage();
  els.onlyFreeStrict.checked = initSettings.strict;
  // incOCM is checked by default so that OCM is included unless user toggles.
  els.incOCM.checked = true;

  /* ===================== SETTINGS MODAL FUNCTIONS ===================== */
  // Open the settings modal: populate fields from storage and sync checkboxes.
  function openSettings(){
    const { ocmKey, strict } = loadSettingsFromStorage();
    els.ocmKeyInput.value = ocmKey;
    els.strictInModal.checked = strict;
    // Sync toolbar strict checkbox
    els.onlyFreeStrict.checked = strict;
    els.settingsModal.style.display = 'block';
    els.settingsModal.setAttribute('aria-hidden','false');
  }
  function closeSettings(){
    els.settingsModal.style.display = 'none';
    els.settingsModal.setAttribute('aria-hidden','true');
  }
  // Toggle visibility of the OCM key field between password and text.
  els.toggleKey.addEventListener('click', () => {
    const type = els.ocmKeyInput.type === 'password' ? 'text' : 'password';
    els.ocmKeyInput.type = type;
    els.toggleKey.textContent = (type === 'password') ? 'Mostra' : 'Nascondi';
  });
  // Save settings and update UI when user clicks "Salva".
  els.saveSettings.addEventListener('click', () => {
    saveSettingsToStorage();
    // Reflect strict choice in toolbar
    els.onlyFreeStrict.checked = els.strictInModal.checked;
    closeSettings();
    setStatus('Impostazioni salvate.', false);
  });
  // Close modal without saving when clicking "Chiudi".
  els.closeSettings.addEventListener('click', closeSettings);
  // Open modal when settings button is clicked.
  els.btnSettings.addEventListener('click', openSettings);

  /* ===================== UTIL ===================== */
  function haversine(lat1, lon1, lat2, lon2){
    const R = 6371000, toRad = d => d*Math.PI/180;
    const dLat = toRad(lat2-lat1), dLon = toRad(lon2-lon1);
    const a = Math.sin(dLat/2)**2 + Math.cos(toRad(lat1))*Math.cos(toRad(lat2))*Math.sin(dLon/2)**2;
    return 2*R*Math.asin(Math.sqrt(a));
  }
  function gridKey(lat, lon){
    return (Math.round(lat*100)/100).toFixed(2)+'_'+(Math.round(lon*100)/100).toFixed(2);
  }
  function setStatus(text, busy=false){
    els.statusText.textContent = text;
    els.spinner.style.display = busy ? 'inline-block' : 'none';
  }
  function batchAddMarkers(points){
    let i=0;
    function step(){
      const end = Math.min(i+40, points.length);
      for(; i<end; i++){
        const p = points[i];
        const popupOperator = p.operator || '';
        const popupConnectors = (p.connectors && p.connectors.length) ? p.connectors.join(', ') : '‚Äî';
        L.marker([p.lat,p.lon]).addTo(markers)
          .bindPopup('<b>'+p.name+'</b><br>' + popupOperator + '<br><small>' + popupConnectors + '</small>');
      }
      if(i < points.length) requestAnimationFrame(step);
    }
    requestAnimationFrame(step);
  }
  function dedupeByProximity(items, meters=25){
    const out = [];
    for(const p of items){
      const match = out.find(o => haversine(o.lat,o.lon,p.lat,p.lon) <= meters);
      if(!match) out.push(p);
    }
    return out;
  }

  /* ===================== NORMALIZZAZIONE OSM ===================== */
  function connectorsFromOSMTags(tags){
    tags = tags || {};
    const mapKey = {
      'socket:type2':'Type2',
      'socket:type2_combo':'CCS2',
      'socket:chademo':'CHAdeMO',
      'socket:type1':'Type1',
      'socket:schuko':'Schuko',
      'socket:tesla_supercharger':'Tesla SC'
    };
    const res = [];
    for(const k in mapKey){
      if(Object.prototype.hasOwnProperty.call(tags, k)){
        const v = (tags[k] || '').toString().trim().toLowerCase();
        if(v && v !== 'no' && v !== '0') res.push(mapKey[k]);
      }
    }
    return res;
  }
  function normalizeOSM(el){
    const isNode = Object.prototype.hasOwnProperty.call(el, 'lat');
    const lat = isNode ? el.lat : ((el.center && el.center.lat) || null);
    const lon = isNode ? el.lon : ((el.center && el.center.lon) || null);
    const tags = el.tags || {};
    if(lat==null || lon==null) return null;
    const name = tags.name || 'Stazione di ricarica';
    const operator = tags.operator || tags.brand || null;
    const connectors = connectorsFromOSMTags(tags);
    const power = tags['charging_power'] || tags['power'] || null;
    const free = (tags.fee && tags.fee.toString().toLowerCase()==='no') ||
                 (tags.charge && tags.charge.toString().trim()==='0');
    return { source:'OSM', free: !!free, name, operator, lat, lon, raw:tags, power, connectors };
  }

  /* ===================== NORMALIZZAZIONE OCM ===================== */
  // List of operator name fragments that almost always indicate paid charging.  Used by
  // strict filtering mode to reject likely paid stations.
  const PAID_OPERATOR_HINTS = [
    'enel', 'enel x', 'enel x way', 'becharge', 'be charge', 'plentitude',
    'evway', 'duferco', 'a2a', 'hera', 'ionity', 'tesla', 'neogy'
  ];
  // Check for textual indications that a station is free (free, gratis, ‚Ç¨0, etc.).
  function hasFreeKeywords(s){
    const t = s.toLowerCase();
    return /\bfree\b|\bgratis?\b|(^|\s)0\s*(‚Ç¨|eur)?\b|‚Ç¨\s*0\b/.test(t);
  }
  // Determine free status under strict rules: explicit free cost AND not run by a known paid operator.
  function isOCMFreeStrict(usageCost, operatorTitle){
    const op = (operatorTitle || '').toLowerCase();
    if(PAID_OPERATOR_HINTS.some(h => op.includes(h))) return false;
    if(usageCost && hasFreeKeywords(String(usageCost))) return true;
    return false;
  }
  // Determine free status under lenient rules: treat unknown cost as free by default.
  function isOCMFreeLenient(usageCost){
    if(!usageCost) return true;
    return hasFreeKeywords(String(usageCost));
  }
  function normalizeOCM(item){
    const a = item.AddressInfo || {};
    if(a.Latitude==null || a.Longitude==null) return null;
    const connections = Array.isArray(item.Connections) ? item.Connections : [];
    // Map connection types to simplified names
    const connectorTitles = connections
      .map(c => (c.ConnectionType && c.ConnectionType.Title) || null)
      .filter(Boolean)
      .map(t => {
        const s = t.toLowerCase();
        if(s.includes('type 2')) return 'Type2';
        if(s.includes('ccs') || s.includes('combo')) return 'CCS';
        if(s.includes('chademo')) return 'CHAdeMO';
        if(s.includes('schuko')) return 'Schuko';
        if(s.includes('tesla')) return 'Tesla';
        return t;
      });
    // Pick the maximum available power value from connections
    let power = null;
    if(connections.length){
      const k = connections.map(c => c.PowerKW || c.Power || 0).filter(n => n > 0);
      if(k.length) power = Math.max(...k) + ' kW';
    }
    // Compute free flag based on strictness and operator info
    const opTitle = (item.OperatorInfo && item.OperatorInfo.Title) || '';
    const usageCost = item.UsageCost || '';
    const strict = !!els.onlyFreeStrict.checked;
    const freeFlag = strict ? isOCMFreeStrict(usageCost, opTitle)
                            : isOCMFreeLenient(usageCost);
    return {
      source:'OCM',
      free: freeFlag,
      name: a.Title || 'Punto di ricarica',
      operator: opTitle || null,
      lat: a.Latitude,
      lon: a.Longitude,
      power: power,
      connectors: [...new Set(connectorTitles)],
      raw: item
    };
  }

  /* ===================== DATI: OSM + OCM ===================== */
  async function fetchOSM(lat, lon, radiusKm){
    const R = Math.round(radiusKm * 1000);
    const q = `
      [out:json][timeout:25];
      (
        node["amenity"="charging_station"]["fee"="no"](around:${R},${lat},${lon});
        node["amenity"="charging_station"]["charge"="0"](around:${R},${lat},${lon});
        way["amenity"="charging_station"]["fee"="no"](around:${R},${lat},${lon});
        way["amenity"="charging_station"]["charge"="0"](around:${R},${lat},${lon});
        relation["amenity"="charging_station"]["fee"="no"](around:${R},${lat},${lon});
        relation["amenity"="charging_station"]["charge"="0"](around:${R},${lat},${lon});
      );
      out center tags;
    `.trim();
    const res = await fetch('https://overpass-api.de/api/interpreter', {
      method:'POST',
      headers:{ 'Content-Type':'application/x-www-form-urlencoded;charset=UTF-8' },
      body: 'data=' + encodeURIComponent(q)
    });
    if(!res.ok) throw new Error('Overpass API error: ' + res.status);
    const json = await res.json();
    const arr = (json.elements || [])
      .map(normalizeOSM)
      .filter(Boolean)
      .map(o => ({...o, free:true}));
    return arr;
  }
  async function fetchOCM(lat, lon, radiusKm){
    // Retrieve API key and strict flag from storage.  The key is optional.
    const { ocmKey } = loadSettingsFromStorage();
    const url = new URL('https://api.openchargemap.io/v3/poi');
    const params = {
      output: 'json',
      latitude: lat,
      longitude: lon,
      distance: radiusKm,
      distanceunit: 'KM',
      countrycode: 'IT',
      maxresults: 300,
      compact: true,
      verbose: false
    };
    Object.entries(params).forEach(([k,v]) => url.searchParams.set(k,v));
    const options = {};
    if(ocmKey){
      // Use HTTP header recommended by OpenChargeMap to avoid logging the key in server logs
      options.headers = { 'X-API-Key': ocmKey };
    }
    const res = await fetch(url.toString(), options);
    if(!res.ok) throw new Error('OCM API error: ' + res.status);
    const json = await res.json();
    return json.map(normalizeOCM).filter(Boolean).filter(p => p.free);
  }

  /* ===================== CACHE (localStorage) ===================== */
  const CACHE_TTL_MS = 15*60*1000;
  function cacheGet(key){
    try{
      const raw = localStorage.getItem(key);
      if(!raw) return null;
      const obj = JSON.parse(raw);
      if(Date.now() - obj.t > CACHE_TTL_MS) return null;
      return obj.data || null;
    }catch{ return null; }
  }
  function cacheSet(key, data){
    try{ localStorage.setItem(key, JSON.stringify({t:Date.now(), data})); }catch{}
  }

  /* ===================== RENDER LISTA ===================== */
  function renderList(items){
    const frag = document.createDocumentFragment();
    items.forEach(p => {
      const div = document.createElement('div');
      div.className = 'item';
      // Build human-friendly strings
      const connectors = (p.connectors && p.connectors.length) ? p.connectors.join(', ') : 'Connettori: n/d';
      const powerText = p.power ? ' ¬∑ ~' + p.power : '';
      const pillLabel = (p.source === 'OSM') ? 'Gratis confermato (OSM)' : 'Gratis probabile (OCM)';
      div.innerHTML = `
        <div class="row">
          <span class="pill ${p.source==='OSM' ? 'osm' : 'ocm'}">${pillLabel}</span>
          <strong>${p.name}</strong>
          <span class="muted">${p.operator || ''}</span>
        </div>
        <div class="muted">${connectors}${powerText}</div>
        <div><a target="_blank" href="https://www.google.com/maps/dir/?api=1&destination=${p.lat},${p.lon}">Apri navigazione</a></div>
      `;
      frag.appendChild(div);
    });
    els.list.replaceChildren(frag);
  }

  /* ===================== LOGICA: caricamento incrementale ===================== */
  let currentCenter = map.getCenter();
  let staged = [5,10,20,30];
  let stagedIndex = 0;
  let combinedPoints = [];

  function getCacheKey(lat, lon, radiusKm){
    return 'fcache_'+gridKey(lat,lon)+'_'+radiusKm;
  }
  async function loadRadius(lat, lon, radiusKm){
    const key = getCacheKey(lat, lon, radiusKm);
    const fromCache = cacheGet(key);
    if(fromCache){ return fromCache; }
    const tasks = [ fetchOSM(lat, lon, radiusKm) ];
    if(els.incOCM.checked){
      // Fetch OCM using the stored API key; no need to pass it from UI
      tasks.push(fetchOCM(lat, lon, radiusKm));
    }
    const results = await Promise.allSettled(tasks);
    const merged = []
      .concat(results[0].status==='fulfilled' ? results[0].value : [])
      .concat(results[1] && results[1].status==='fulfilled' ? results[1].value : []);
    const unique = dedupeByProximity(merged, 30);
    cacheSet(key, unique);
    return unique;
  }
  async function stagedLoad(startLat, startLon, fromIndex=0){
    stagedIndex = fromIndex;
    els.moreBtn.style.display = (stagedIndex < staged.length-1) ? 'inline-block' : 'none';
    for(; stagedIndex<staged.length; stagedIndex++){
      const r = staged[stagedIndex];
      setStatus('Cerco entro '+r+' km...', true);
      const points = await loadRadius(startLat, startLon, r);
      const existing = combinedPoints;
      const newly = points.filter(p => !existing.some(e => haversine(e.lat,e.lon,p.lat,p.lon) < 20));
      if(newly.length){
        combinedPoints = dedupeByProximity(existing.concat(newly), 20);
        batchAddMarkers(newly);
        renderList(combinedPoints);
      }
      setStatus('Trovati '+combinedPoints.length+' punti (entro '+r+' km).', stagedIndex < staged.length-1);
      els.moreBtn.style.display = (stagedIndex < staged.length-1) ? 'inline-block' : 'none';
      if(stagedIndex === 0) break;
    }
  }

  /* ===================== EVENTI UI ===================== */
  els.btnLoc.addEventListener('click', () => {
    setStatus('Rilevo la posizione...', true);
    navigator.geolocation.getCurrentPosition(async pos => {
      const lat = pos.coords.latitude, lon = pos.coords.longitude;
      currentCenter = L.latLng(lat, lon);
      map.setView(currentCenter, 13);
      markers.clearLayers();
      els.list.textContent = '';
      combinedPoints = [];
      stagedIndex = 0;
      els.radius.value = 10; els.radiusOut.textContent = '10';
      staged = [5,10,20,30];
      await stagedLoad(lat, lon, 0);
    }, err => {
      setStatus('Posizione non disponibile. Usa ‚ÄúCerca nell‚Äôarea mappa‚Äù.', false);
    }, { enableHighAccuracy:true, timeout:10000, maximumAge:60000 });
  });
  els.btnSearch.addEventListener('click', async () => {
    const c = map.getCenter();
    currentCenter = c;
    markers.clearLayers(); els.list.textContent='';
    combinedPoints = [];
    const maxR = parseInt(els.radius.value,10) || 30;
    staged = [5, Math.min(10,maxR)];
    if(maxR>10) staged.push(20);
    if(maxR>20) staged.push(30);
    setStatus('Cerco nell‚Äôarea visualizzata...', true);
    await stagedLoad(c.lat, c.lng, 0);
  });
  els.moreBtn.addEventListener('click', async () => {
    if(!currentCenter) return;
    const c = currentCenter;
    if(stagedIndex < staged.length-1){
      stagedIndex++;
      const r = staged[stagedIndex];
      setStatus('Espando a '+r+' km...', true);
      const points = await loadRadius(c.lat, c.lng, r);
      const newly = points.filter(p => !combinedPoints.some(e => haversine(e.lat,e.lon,p.lat,p.lon) < 20));
      if(newly.length){
        combinedPoints = dedupeByProximity(combinedPoints.concat(newly), 20);
        batchAddMarkers(newly);
        renderList(combinedPoints);
      }
      setStatus('Trovati '+combinedPoints.length+' punti (entro '+r+' km).', stagedIndex < staged.length-1);
      els.moreBtn.style.display = (stagedIndex < staged.length-1) ? 'inline-block' : 'none';
    } else {
      els.moreBtn.style.display = 'none';
    }
  });

  /* ===================== AVVIO RAPIDO ===================== */
  addEventListener('load', async () => {
    els.radius.value = 10; els.radiusOut.textContent = '10';
    const c = map.getCenter();
    currentCenter = c;
    markers.clearLayers(); els.list.textContent='';
    combinedPoints = [];
    staged = [5,10,20,30];
    setStatus('Carico punti vicini (5 km)...', true);
    await stagedLoad(c.lat, c.lng, 0);
  });
  </script>
</body>
</html>